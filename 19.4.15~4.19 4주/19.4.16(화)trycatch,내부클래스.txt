19.4.16(화)
try catch문
	try{실행문;}catch(에러조건 변수명){에러시 바로 실행}	
	try catch는 에러가 나는 순간 catch문 실행으로 넘어간다.
	try문 안에서 선언된 변수의 라이프 사이클은 try문 안 쪽 까지다.(for문을 떠올려보자)
	객체에서 에러가 나면 그 객체는 고장난다.. 재활용 시에도 에러
다중 catch문.
	try{실행문;}catch(에러명 변수명){실행}catch(에러명 변수명){실행}
	if else문 마냥 쓰면 된다.
	주의 사항:먼저 오는 catch문이 상위의 Exception클래스(누가 더 상위인지는 api문서 참조)를 다루고
	있으면 뒤까지 안오겠지..다중캐치문에서는 뒤편에 상위의 에러클래스를 놔야한다.
	
	마찬가지 맥락에서 하나의 캐치문으로 모든 에러를 처리하게 하고 싶으면 
	Exception 클래스를 동원하면 된다.ex)try{실행문}catch(Exception e){실행};
	Exception 클래스를 전가의 보도처럼 휘두르지 말자. 예상치못한 에러를 찾아내지 못할수도 있으니

	설정한 에러의 변수에는 에러이름과 에러원인이 담기게된다.

에러와 예외의 최상위클래스 Throwable 클래스
	메소드
	toString() 에러명과 에러원인 간단하게 한줄로 반환. String 반환
	getMessage() 예외객체가 기억하고 있던 내용 반환. String 반환
	printStackTrace() 에러화면에 출력되는 메세지와 동일하게 출력. 출력되는 위치는 지맘임. void. <<권장

클래스에 붙는 throws.
	위치는 extends,implements 위치와 동일. 메소드에도 붙을 수 있음. throws 에러명을 하면
	에러가 나는 순간 에러명을 리턴.
	throw 명령어는 return처럼 사용

사용자정의 exception.
	MyException클래스를 만들어서 Exception을 상속받게 만들고, 해당 객체를 활용해서 내가 원하는 상황에
	 에러가 나게, 또 에러시 조치하게 할 수 있다

finally문
	try catch문 뒤에 붙어 에러발생유무와 상관없이 반드시 실행된다. t/c문에서 리턴이 있는 상황이더라도 실행된다.
	무 조 건 실행 try finally문도 가능. 에러가 목적이 아닌 반드시 실행이 목적

내부 클래스
	종류
		static		:static안에서 static이면 main문에서 Inner.변수/메소드 로 사용. nonstatic이면 객체를 생성해서 사용.
				외부클래스에서의 접근은 패키지주소가 하나 추가된 것처럼 활용하면 됨. 내부클래스는 여타 클래스와 달리
				private 사용도 가능.

		non-static	:보통 클래스와는 달리 nonstatic 내부클래스는 객체로 생성하지 전까지는 존재하지 않는 것이기 때문에 
				static 변수, static 메소드를 생성할 수 없다. 예외적으로 final명령어는 허용해줌.
				접근하려면 객체를 생성후 그 객체안에 내부클래스 객체를 생성하는 방식으로 접근해야한다.
				ex)클래스 Ex01, 내부nonstatic클래스 Inner 라면 Inner inn = new Ex01().new Inner()
				외부에서 접근하려면 Ex01.Inner inn = new Ex01().new Inner();가 되겠다.

		local		:메소드안에 있는 클래스. 마치 멤버필드처럼 쓰인다. static으로 사용하는 것은 불가능하다.
				마찬가지로 내부에 있는 요소들도 static으로 쓸 수 없다. 다만 final은 예외
				메소드 내부에서 객체를 생성하여 사용할 수 있다. 메소드에서 가져다가 쓸 수 있는 변수는 final만 가능하다.
				아니라면 변수에따라 클래스가 예기치않게 바뀔 수 있는 문제점이 있어서. . .지만 jdk1.8부터 변수도 사용 가능하다.

		anonymous	:클래스를 리턴타입으로 주고 싶을 때 리턴 뒤를 클래스내용으로 채우는 것이다. Ex)inner class Ex01 implements Real(){};라면
				return type을 Real로 주고 return new Real(){};로 가면 된다.
				생성자가 없는 interface의 객체를 생성하고 싶을 때 활용하는 내부 클래스. interface를 리턴타입으로 주고 retrun 뒤를
				클래스의 내용으로 채우는 것이다. class는 기본생성자가 있으니까. 
				클로져 역할도 할 수 있다. 클로저란 내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있게 해주는 개념인데,
				한번만 쓰는 클래스를 사용함으로써 그 클래스의 참조변수가 담긴 객체가 클로저의 역할을 수행할 수 있다.

	내부클래스에서 바깥 클래스들에 접근할때는 보통의 방식과 동일. non-static 내부클래스의 경우에는 상속받은 클래스처럼 기능한다.